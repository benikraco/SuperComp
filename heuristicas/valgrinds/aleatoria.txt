--------------------------------------------------------------------------------
-- User-annotated source: aleatoria.cpp
--------------------------------------------------------------------------------
Ir      

-- line 12 ----------------------------------------
      .  };
      .  
      .  // Function prototypes
      .  bool compareMovies(const Movie &a, const Movie &b);
      .  bool timeOverlap(int start1, int end1, int start2, int end2);
      .  std::vector<Movie> readMovies(std::string filename, int &N, int &M, std::vector<int> &maxMoviesPerCategory);
      .  
      .  // Compare function for sorting movies by end time, and start time in case of a tie
125,707  bool compareMovies(const Movie &a, const Movie &b) {
377,121      if (a.end == b.end) {
215,082          return a.start < b.start;
      .      }
251,414      return a.end < b.end;
251,414  }
      .  
      .  // Function to check if two time intervals overlap
      .  bool timeOverlap(int start1, int end1, int start2, int end2) {
      .      return start1 < end2 && start2 < end1;
      .  }
      .  
      .  // Function to read movies from input file and return a vector of Movie structures
     16  std::vector<Movie> readMovies(std::string filename, int &N, int &M, std::vector<int> &maxMoviesPerCategory) {
      .      std::ifstream inputFile(filename);
      .  
      .      // Read the number of movies and categories from the input file
      6      inputFile >> N >> M;
  6,677  => ???:0x000000000010a350 (2x)
      .  
      .      // Resize the maxMoviesPerCategory vector according to the number of categories
      2      maxMoviesPerCategory.resize(M);
      .  
      .      // Read the maximum number of movies per category
     64      for (int i = 0; i < M; i++) {
     40          inputFile >> maxMoviesPerCategory[i];
  8,586  => ???:0x000000000010a350 (20x)
      .      }
      .  
      .      // Initialize the movies vector with the number of movies
      1      std::vector<Movie> movies(N);
      .  
      .      // Read the movie information
 28,715      for (int i = 0; i < N; i++) {
 90,000          inputFile >> movies[i].start >> movies[i].end >> movies[i].category;
13,082,583  => ???:0x000000000010a350 (30,000x)
 40,000          if (movies[i].end < movies[i].start) {
  2,580              movies[i].end += 24;
      .          }
 11,290          movies[i].index = i; // Set the index of the movie
      .      }
      .  
      .      // Close the input file
      .      inputFile.close();
      .      return movies;
     12  }
      .  
     16  int main(int argc, char* argv[]) {
      2      if (argc != 2) {
      .          std::cerr << "Usage: " << argv[0] << " <input_file>" << std::endl;
      .          return 1;
      .      }
      .  
      1      std::string input_file = argv[1];
      .      int N, M;
      .      std::vector<int> maxMoviesPerCategory;
      .  
      .      // Passe o nome do arquivo de input para a função readMovies
      6      std::vector<Movie> movies = readMovies(input_file, N, M, maxMoviesPerCategory);
13,400,146  => aleatoria.cpp:readMovies(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int&, int&, std::vector<int, std::allocator<int> >&) (1x)
      .      
      .  
      .      // Sort the movies by end time, and start time in case of a tie
      .      std::sort(movies.begin(), movies.end(), compareMovies);
      .  
      .      // Initialize the chosenMoviesPerCategory vector
      1      std::vector<int> chosenMoviesPerCategory(M, 0);
      .      std::vector<Movie> chosenMovies;
      2      int moviesWatched = 0;
      .  
      .      // Initialize a vector to track which movies have been selected
      1      std::vector<bool> movieSelected(N, false);
      .  
      .      // Initialize the random number generator
      3      std::random_device rd;
  2,891  => /usr/include/c++/9/bits/random.h:std::random_device::random_device() (1x)
      1      std::mt19937 gen(rd());
      .      std::uniform_real_distribution<double> distribution(0.0, 1.0);
      2      gen.seed(rd() + time(0));
      8  => ???:0x000000000010a3b0 (1x)
      .  
      .      // Start the timer
      2      auto startTime = std::chrono::steady_clock::now();
    950  => ???:0x000000000010a450 (1x)
      .  
      .      // Iterate over the sorted movies
 30,002      for (const Movie &movie : movies) {
      .  
      .          // Check if the movie doesn't cross the day boundary and there are available slots for the movie category
159,568          if (!movieSelected[movie.index] && movie.end > movie.start && chosenMoviesPerCategory[movie.category - 1] < maxMoviesPerCategory[movie.category - 1]) {
      .              bool conflict = false;
      .  
      .              // Check for conflicts with other chosen movies
374,552              for (const Movie &chosenMovie : chosenMovies) {
499,308                  if (timeOverlap(chosenMovie.start, chosenMovie.end, movie.start, movie.end)) {
      .                      conflict = true;
      .                      break;
      .                  }
      .              }
      .  
      .              // If there's no conflict, increment the chosen movies count for the category
      .              if (!conflict) {
      .                  double randomValue = distribution(gen);
     72                  if (randomValue <= 0.25) {
      .  
      .                      // Find an alternative movie respecting the time constraints (25% chance)
 55,564                      for (const Movie &alternativeMovie : movies) {
      .  
      .                          // Skip if the alternative movie has already been selected
111,136                          if (movieSelected[alternativeMovie.index]) {
      .                              continue;
      .                          }
      .  
      .                          bool altConflict = false;
      .  
      .                          // Check for conflicts with other chosen movies
634,108                          for (const Movie &chosenMovie : chosenMovies) {
989,932                              if (timeOverlap(chosenMovie.start, chosenMovie.end, alternativeMovie.start, alternativeMovie.end)) {
      .                                  altConflict = true;
      .                                  break;
      .                              }
      .                          }
      .  
      .                          // Check if the alternative movie doesn't cross the day boundary and there are available slots for the movie category
  1,706                          if (!altConflict && chosenMoviesPerCategory[alternativeMovie.category - 1] < maxMoviesPerCategory[alternativeMovie.category - 1] && alternativeMovie.start != alternativeMovie.end) {
     16                              chosenMoviesPerCategory[alternativeMovie.category - 1]++;
      8                              moviesWatched++;
     24                              chosenMovies.push_back(alternativeMovie);
  1,677  => /usr/include/c++/9/bits/stl_vector.h:std::vector<Movie, std::allocator<Movie> >::push_back(Movie const&) (8x)
     16                              movieSelected[alternativeMovie.index] = true; // Mark the alternative movie as selected
      .                              break;
      .                          }
      .                      }
      .  
      .                  // Otherwise, select the current movie
      .                  } else {
     80                      chosenMoviesPerCategory[movie.category - 1]++;
     16                      moviesWatched++;
     48                      chosenMovies.push_back(movie);
  1,005  => /usr/include/c++/9/bits/stl_vector.h:std::vector<Movie, std::allocator<Movie> >::push_back(Movie const&) (16x)
     64                      movieSelected[movie.index] = true; // Mark the movie as selected
      .                  }
      .              }
      .          }
      .      }
      .  
      .      // Stop the timer
      1      auto endTime = std::chrono::steady_clock::now();
     40  => ???:0x000000000010a450 (1x)
      .  
      .      // Calculate the time elapsed during algorithm execution
      3      double duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime).count();
      .  
      .      // Sort the chosenMovies vector by end time, and start time in case of a tie
      .      std::sort(chosenMovies.begin(), chosenMovies.end(), compareMovies);
      .  
      .      // Print the number of movies watched
      4      std::cout << "Movies watched: " << moviesWatched << std::endl;
  4,669  => ???:0x000000000010a500 (1x)
      .  
      .      // Print the start and end times, and category of the selected movies
     76      for (const Movie &movie : chosenMovies) {
    288          std::cout << "Movie start: " << movie.start << ", end: " << movie.end << ", category: " << movie.category << std::endl;
 29,963  => ???:0x000000000010a500 (72x)
      .      }
      .  
      .      // Print the time elapsed during the aleatory algorithm execution
      .      std::cout << "Time elapsed during the aleatory algorithm: " << duration << " microseconds" << std::endl;
     16  }
--------------------------------------------------------------------------------
Ir        
--------------------------------------------------------------------------------
4,250,109  events annotated